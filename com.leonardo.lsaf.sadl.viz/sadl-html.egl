[% 
  import "sadl.eol";
  import "nestedport.eol";

  createPort();
  var connections = Sequence{};
%]
<html>
<head>
    <link rel="stylesheet" href="css/sadl.css" />
    <script type="text/javascript" src="js/mxClient-min.js"></script>
    <script type="text/javascript" src="js/elk.bundled-min.js"></script>
    <script type="text/javascript" src="js/adlviz.js"></script>
    <title>[%=application.getFullNameStr()%]</title>
</head>
<body>
    <h1>
        [%=application.getFullNameStr()%]
    </h1>
    <div id="graphContainer" class="viewport">
    </div>
    <div id="viewport">
    </div>
    
        <script type="text/javascript">
            const elk = new ELK({
                workerUrl: 'js/elk-worker-min.js'
            });
            
            const elkGraph = 
            {
                "id": "root",
                "layoutOptions": { "elk.algorithm": "layered" },
                "children": [
[% 
    for (subContainer in application.containerInstances) {
       var containerStack = Sequence{};
        var visited = Set{};
        var iteratorMap = Map{};
        
        var applicationNode = createNode();
        applicationNode.id = application.name;
        applicationNode.label = application.name;
        applicationNode.packageableElement = application;
        applicationNode.level = -1;
        applicationNode.width = DEFAULT_COMPONENT_WIDTH();
        applicationNode.height = DEFAULT_COMPONENT_HEIGHT();
        applicationNode.class = application.eClass.getName(); 
        
        populateContainerStack(applicationNode, applicationNode, subContainer.type, 0, containerStack);
        containerStack.println;
        
        var prevNode = null;
        for (node in containerStack) {
%]
[%
            if (prevNode == null) {
%]
                    // A
                    { "id": "[%=node.id%]", 
                        "labels": [{"text": "[%=node.label%]"}],
                        "properties": {
                            "portConstraints": "FIXED_POS"
                        },
[%
            }
            if (prevNode <> null and node.level > prevNode.level) {
%]
                    // B
                              "children": [
                    { "id": "[%=node.id%]", 
                        "labels": [{"text": "[%=node.label%]"}],
                        "properties": {
                            "portConstraints": "FIXED_POS"
                        },
[%
            }
            if (prevNode <> null and node.level == prevNode.level) {
%]
                    // C
                        "width": [%=node.width%], 
                        "height": [%=node.height%], 
                        "class":"[%=node.class%]" 
                    },
                    { "id": "[%=node.id%]", 
                        "labels": [{"text": "[%=node.label%]"}],
                        "properties": {
                            "portConstraints": "FIXED_POS"
                        },
[%
            }
            if (prevNode <> null and node.level < prevNode.level) {
%]
                    // D
                        "width": [%=node.width%], 
                        "height": [%=node.height%], 
                        "class":"[%=node.class%]" 
                    },
[% for (i in Sequence{1..prevNode.level-node.level}) { %]
                    ],
                        "width": [%=node.width%], 
                        "height": [%=node.height%], 
                        "class":"[%=node.class%]" 
                    },
[% } %]
                    { "id": "[%=node.id%]", 
                        "labels": [{"text": "[%=node.label%]"}],
                        "properties": {
                            "portConstraints": "FIXED_POS"
                        },
[%
            }
%]
[% /* closing tags */ %]
[%
            if (node == containerStack.get(containerStack.size - 1)) {
%]
                    // F
[% for (i in Sequence{1..node.level}) { %]
                    //],
[% } %]
                        "width": [%=node.width%], 
                        "height": [%=node.height%], 
                        "class":"[%=node.class%]" 
                    },
[% 
var i = 0;
while(i < node.level) { %]
                    ],},
[% i++; } %]
[%
            }
%]
[%
            prevNode = node;
        } 


    }
%]
                ]
            }
    </script>

    <!-- Render -->
    <script type="text/javascript">
        elk.layout(elkGraph)
            .then(function (g) {
                var viewport = document.getElementById("viewport");
                render(document.getElementById('graphContainer'), elkGraph);
                viewport.innerHTML = "<pre>" + JSON.stringify(g, null, " ") + "</pre>"
            })
            .catch(console.error);
    </script>
</body>

</html>
 
[%
operation populateContainerStack(rootNode, parentNode, element, level, containerStack) {
    var node = createNode();
    node.id = parentNode.id + "-" + element.name;
    node.label = element.name;
    node.packageableElement = element;
    node.level = level;
    node.class = element.eClass.getName();
    node.width = DEFAULT_COMPONENT_WIDTH();
    node.height = DEFAULT_COMPONENT_HEIGHT();
    node.parent = parentNode; 
    parentNode.children.add(node);
    
    containerStack.add(node);
    
    level = level + 1;
    if (element.isTypeOf(Container)) {
        for (containerInstance in element.containerInstances) {
            populateContainerStack(rootNode, node, containerInstance.type, level, containerStack);
        }
        for (componentInstance in element.componentInstances) {
            populateContainerStack(rootNode, node, componentInstance.type, level, containerStack);
        }
    }
    if (element.isTypeOf(Component)) {
        for (componentInstance in element.parts) {
            populateContainerStack(rootNode, node, componentInstance.type, level, containerStack);
        }
    }
    level = level - 1;
}
%]

